    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
      <head>
        <title>src/environment.rb - C0 code coverage information</title>
        <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
        <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
        <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
        <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
      </head>
      <body>
        <h3>C0 code coverage information</h3>
        <p>Generated on Thu Oct 11 01:02:20 -0500 2007 with <a href='http://eigenclass.org/hiki.rb?rcov'>rcov 0.8.0</a>
        </p>
        <hr /><pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <tr class='light'>
          <td>
            <a href='src-environment_rb.html'>src/environment.rb</a>
          </td>
          <td class='lines_total'>
            <tt>694</tt>
          </td>
          <td class='lines_code'>
            <tt>527</tt>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_total'>83.0%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='83' />
                      <td class='uncovered' width='17' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_code'>77.8%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='78' />
                      <td class='uncovered' width='22' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </tbody>
    </table><pre><span class="marked1"><a name="line1" />  1 $: &lt;&lt; File.dirname(__FILE__)
</span><span class="inferred0"><a name="line2" />  2 
</span><span class="marked1"><a name="line3" />  3 require 'thread'
</span><span class="marked0"><a name="line4" />  4 require 'sandbox'
</span><span class="marked1"><a name="line5" />  5 require 'delegator'
</span><span class="marked0"><a name="line6" />  6 require 'pipe'
</span><span class="marked1"><a name="line7" />  7 require 'host'
</span><span class="marked0"><a name="line8" />  8 require 'untrace'
</span><span class="marked1"><a name="line9" />  9 require 'rest/rest'
</span><span class="marked0"><a name="line10" /> 10 require 'uri'
</span><span class="marked1"><a name="line11" /> 11 require 'ext'
</span><span class="inferred0"><a name="line12" /> 12 
</span><span class="inferred1"><a name="line13" /> 13 
</span><span class="inferred0"><a name="line14" /> 14 # Script environment handles states, functions, classes,
</span><span class="inferred1"><a name="line15" /> 15 # messaging, url mapping, sandboxing, and security.
</span><span class="marked0"><a name="line16" /> 16 class Environment
</span><span class="inferred1"><a name="line17" /> 17 
</span><span class="marked0"><a name="line18" /> 18 	include Untrace
</span><span class="marked1"><a name="line19" /> 19 	extend PartialDelegator
</span><span class="inferred0"><a name="line20" /> 20 
</span><span class="marked1"><a name="line21" /> 21 	attr_accessor :name
</span><span class="inferred0"><a name="line22" /> 22 
</span><span class="inferred1"><a name="line23" /> 23 	# set stuff up, taint some of it
</span><span class="marked0"><a name="line24" /> 24 	def initialize(input=$stdin, output=$stdout, in_memory=false)
</span><span class="marked1"><a name="line25" /> 25 		@pipe = MessagePipe.new input, output unless in_memory
</span><span class="marked0"><a name="line26" /> 26 		@included = []
</span><span class="marked1"><a name="line27" /> 27 		@inbox = []
</span><span class="marked0"><a name="line28" /> 28 		@replies = []
</span><span class="marked1"><a name="line29" /> 29 		@sandbox = Sandbox.new
</span><span class="marked0"><a name="line30" /> 30 		@sandbox.extend REST
</span><span class="marked1"><a name="line31" /> 31 		@mutex = Mutex.new
</span><span class="marked0"><a name="line32" /> 32 		@state = [:global].taint
</span><span class="marked1"><a name="line33" /> 33 		@classes = {}.taint
</span><span class="marked0"><a name="line34" /> 34 		@functions = {}.taint
</span><span class="marked1"><a name="line35" /> 35 		@start = false
</span><span class="marked0"><a name="line36" /> 36 		@required = [].taint
</span><span class="marked1"><a name="line37" /> 37 		@states = [].taint
</span><span class="marked0"><a name="line38" /> 38 		@outbox = [].taint
</span><span class="marked1"><a name="line39" /> 39 		@url_patterns = {}.taint
</span><span class="marked0"><a name="line40" /> 40 		@listeners = {}.taint
</span><span class="marked1"><a name="line41" /> 41 		@handlers = {}.taint
</span><span class="marked0"><a name="line42" /> 42 		@in_memory = in_memory
</span><span class="marked1"><a name="line43" /> 43 		@quit_sent = false
</span><span class="marked0"><a name="line44" /> 44 		state(:global) {}
</span><span class="marked1"><a name="line45" /> 45 		start_io_threads
</span><span class="marked0"><a name="line46" /> 46 		add_script_commands
</span><span class="marked1"><a name="line47" /> 47 		add_script_variables
</span><span class="inferred0"><a name="line48" /> 48 	end
</span><span class="inferred1"><a name="line49" /> 49 
</span><span class="inferred0"><a name="line50" /> 50 	# reset the input/output pipes
</span><span class="marked1"><a name="line51" /> 51 	def set_io(input, output, type='MessagePipe')
</span><span class="marked0"><a name="line52" /> 52 		@pipe = type.constantize.new input, output
</span><span class="marked1"><a name="line53" /> 53 	end
</span><span class="inferred0"><a name="line54" /> 54 
</span><span class="inferred1"><a name="line55" /> 55 	# start IO processing threads
</span><span class="marked0"><a name="line56" /> 56 	def start_io_threads
</span><span class="marked1"><a name="line57" /> 57 		@pipe_thread = Thread.new(self) do |env|
</span><span class="marked0"><a name="line58" /> 58 			env.pipe_main
</span><span class="inferred1"><a name="line59" /> 59 		end
</span><span class="marked0"><a name="line60" /> 60 		@io_thread = Thread.new(self) do |env|
</span><span class="marked1"><a name="line61" /> 61 			env.io_main
</span><span class="inferred0"><a name="line62" /> 62 		end
</span><span class="inferred1"><a name="line63" /> 63 	end
</span><span class="inferred0"><a name="line64" /> 64 
</span><span class="inferred1"><a name="line65" /> 65 	# add script-accessible (unsafe) functions
</span><span class="marked0"><a name="line66" /> 66 	def add_script_commands
</span><span class="marked1"><a name="line67" /> 67 		%w(	map current_state resource req
</span><span class="inferred0"><a name="line68" /> 68 				require k goto klass quit &lt;&lt;
</span><span class="inferred1"><a name="line69" /> 69 				state function fun reply pass err
</span><span class="inferred0"><a name="line70" /> 70 				private public params outbox log dbg
</span><span class="inferred1"><a name="line71" /> 71 				entity behavior store handle listen
</span><span class="inferred0"><a name="line72" /> 72 				get put post delete).each do |cmd|
</span><span class="marked1"><a name="line73" /> 73 			@sandbox.delegate cmd.to_sym, self
</span><span class="inferred0"><a name="line74" /> 74 		end
</span><span class="marked1"><a name="line75" /> 75 	end
</span><span class="inferred0"><a name="line76" /> 76 
</span><span class="inferred1"><a name="line77" /> 77 	# add script-accessible (unsafe) variables
</span><span class="marked0"><a name="line78" /> 78 	def add_script_variables
</span><span class="marked1"><a name="line79" /> 79 		%w(outbox classes functions required
</span><span class="inferred0"><a name="line80" /> 80 		   states state io_thread).each do |var|
</span><span class="marked1"><a name="line81" /> 81 			eval &quot;@sandbox[:#{var}] = @#{var}&quot;
</span><span class="inferred0"><a name="line82" /> 82 		end
</span><span class="marked1"><a name="line83" /> 83 	end
</span><span class="inferred0"><a name="line84" /> 84 
</span><span class="inferred1"><a name="line85" /> 85 	# the given block will have no access to the environment
</span><span class="inferred0"><a name="line86" /> 86 	# except what is explicitly given above
</span><span class="marked1"><a name="line87" /> 87 	def sandbox(args={}, &amp;block)
</span><span class="marked0"><a name="line88" /> 88 		@sandbox ||= Sandbox.new
</span><span class="marked1"><a name="line89" /> 89 		args.each {|arg,val| @sandbox[arg] = val}
</span><span class="marked0"><a name="line90" /> 90 		return_value = untraced(1) { @sandbox.sandbox &amp;block }
</span><span class="marked1"><a name="line91" /> 91 		args.each {|arg,val| @sandbox[arg] = nil}
</span><span class="marked0"><a name="line92" /> 92 		return_value
</span><span class="inferred1"><a name="line93" /> 93 	end
</span><span class="inferred0"><a name="line94" /> 94 
</span><span class="inferred1"><a name="line95" /> 95 	# load a script file
</span><span class="marked0"><a name="line96" /> 96 	def load_script(name)
</span><span class="marked1"><a name="line97" /> 97 		File.read name
</span><span class="marked0"><a name="line98" /> 98 	end
</span><span class="inferred1"><a name="line99" /> 99 
</span><span class="inferred0"><a name="line100" />100 	# add a script to the environment.
</span><span class="inferred1"><a name="line101" />101 	# this method can't really get shorter or simpler, unfortunately.
</span><span class="marked0"><a name="line102" />102 	def add_script(name, text=nil)
</span><span class="marked1"><a name="line103" />103 		untraced(2) do
</span><span class="inferred0"><a name="line104" />104 			# push previous require (depth-first order)
</span><span class="marked1"><a name="line105" />105 			protect :required do
</span><span class="marked0"><a name="line106" />106 				text ||= load_script name
</span><span class="marked1"><a name="line107" />107 				@required = [].taint
</span><span class="inferred0"><a name="line108" />108 				# repeat until script and dependencies are loaded
</span><span class="marked1"><a name="line109" />109 				while true
</span><span class="marked0"><a name="line110" />110 					sandbox(:script =&gt; name, :text =&gt; text, :env =&gt; self) do
</span><span class="marked1"><a name="line111" />111 						error = [].taint
</span><span class="marked0"><a name="line112" />112 						Thread.new(@script, @text, error, self) do |script,text,error,box|
</span><span class="marked1"><a name="line113" />113 							$SAFE = 0
</span><span class="marked0"><a name="line114" />114 							$env = box
</span><span class="marked1"><a name="line115" />115 							begin
</span><span class="marked0"><a name="line116" />116 								box.untraced(0,3) do
</span><span class="marked1"><a name="line117" />117 									begin
</span><span class="marked0"><a name="line118" />118 										box.instance_eval text, script
</span><span class="inferred1"><a name="line119" />119 									rescue
</span><span class="marked0"><a name="line120" />120 										box.rename_backtrace $!, '(toplevel)'
</span><span class="marked1"><a name="line121" />121 										fail $!
</span><span class="inferred0"><a name="line122" />122 									end
</span><span class="inferred1"><a name="line123" />123 								end
</span><span class="inferred0"><a name="line124" />124 							rescue
</span><span class="marked1"><a name="line125" />125 								error &lt;&lt; $!
</span><span class="inferred0"><a name="line126" />126 							end
</span><span class="inferred1"><a name="line127" />127 						end.join
</span><span class="inferred0"><a name="line128" />128 						# bubble real errors
</span><span class="marked1"><a name="line129" />129 						unless (error = error[0]).nil?
</span><span class="marked0"><a name="line130" />130 							raise error unless error.message == &quot;require&quot;
</span><span class="inferred1"><a name="line131" />131 						end
</span><span class="inferred0"><a name="line132" />132 					end
</span><span class="inferred1"><a name="line133" />133 					# load required files
</span><span class="marked0"><a name="line134" />134 					break if @required.empty?
</span><span class="marked1"><a name="line135" />135 					until @required.empty?
</span><span class="marked0"><a name="line136" />136 						to_include = @required.shift
</span><span class="marked1"><a name="line137" />137 						add_script to_include
</span><span class="marked0"><a name="line138" />138 						@included &lt;&lt; to_include
</span><span class="inferred1"><a name="line139" />139 					end
</span><span class="inferred0"><a name="line140" />140 				end
</span><span class="inferred1"><a name="line141" />141 			end
</span><span class="inferred0"><a name="line142" />142 		end
</span><span class="marked1"><a name="line143" />143 	end
</span><span class="inferred0"><a name="line144" />144 
</span><span class="inferred1"><a name="line145" />145 	# make a stack of instance variables for nested calls
</span><span class="marked0"><a name="line146" />146 	def protect(*args, &amp;block)
</span><span class="marked1"><a name="line147" />147 		backup = {}
</span><span class="marked0"><a name="line148" />148 		params = args.map {|arg| backup[arg] = eval &quot;@#{arg}&quot;}
</span><span class="marked1"><a name="line149" />149 		params.clear unless block.arity &gt; 0
</span><span class="marked0"><a name="line150" />150 		return_value = untraced(2) { block.call *params }
</span><span class="marked1"><a name="line151" />151 		backup.each {|arg,val| eval &quot;@#{arg} = val&quot;}
</span><span class="marked0"><a name="line152" />152 		return_value
</span><span class="inferred1"><a name="line153" />153 	end
</span><span class="inferred0"><a name="line154" />154 
</span><span class="inferred1"><a name="line155" />155 	# synchronize on a mutex for the given name
</span><span class="marked0"><a name="line156" />156 	def sync(name, &amp;block)
</span><span class="marked1"><a name="line157" />157 		mutex = nil
</span><span class="marked0"><a name="line158" />158 		@mutex.synchronize do
</span><span class="marked1"><a name="line159" />159 			mutex = eval &quot;@#{name}_mutex ||= Mutex.new&quot;
</span><span class="inferred0"><a name="line160" />160 		end
</span><span class="marked1"><a name="line161" />161 		untraced(2) { mutex.synchronize &amp;block }
</span><span class="inferred0"><a name="line162" />162 	end
</span><span class="inferred1"><a name="line163" />163 
</span><span class="inferred0"><a name="line164" />164 	# run the script environment. any errors will be thrown
</span><span class="inferred1"><a name="line165" />165 	# from self.join. won't actually execute scripts until
</span><span class="inferred0"><a name="line166" />166 	# the start message is recieved or start! is called.
</span><span class="marked1"><a name="line167" />167 	def run
</span><span class="marked0"><a name="line168" />168 		return if @trying_to_run
</span><span class="marked1"><a name="line169" />169 		@trying_to_run = true
</span><span class="marked0"><a name="line170" />170 		Thread.pass until @start
</span><span class="marked1"><a name="line171" />171 		@outbox &lt;&lt; [:started, nil, nil]
</span><span class="marked0"><a name="line172" />172 		Thread.pass
</span><span class="marked1"><a name="line173" />173 		@main_thread = Thread.new(self) do |env|
</span><span class="marked0"><a name="line174" />174 			env.script_main
</span><span class="inferred1"><a name="line175" />175 		end
</span><span class="inferred0"><a name="line176" />176 	end
</span><span class="inferred1"><a name="line177" />177 
</span><span class="inferred0"><a name="line178" />178 	# give the environment the green light
</span><span class="marked1"><a name="line179" />179 	def start!
</span><span class="marked0"><a name="line180" />180 		@start = true
</span><span class="marked1"><a name="line181" />181 	end
</span><span class="inferred0"><a name="line182" />182 
</span><span class="inferred1"><a name="line183" />183 	# run right now, don't wait for start signal
</span><span class="marked0"><a name="line184" />184 	def run!
</span><span class="marked1"><a name="line185" />185 		start!
</span><span class="marked0"><a name="line186" />186 		run
</span><span class="inferred1"><a name="line187" />187 	end
</span><span class="inferred0"><a name="line188" />188 
</span><span class="inferred1"><a name="line189" />189 	# main script loop
</span><span class="marked0"><a name="line190" />190 	def script_main
</span><span class="marked1"><a name="line191" />191 		@sandbox[:main_thread] = Thread.current
</span><span class="marked0"><a name="line192" />192 		begin untraced(2,4) do
</span><span class="marked1"><a name="line193" />193 			sandbox do
</span><span class="marked0"><a name="line194" />194 				$env = self
</span><span class="marked1"><a name="line195" />195 				until @exit
</span><span class="marked0"><a name="line196" />196 					$env.start
</span><span class="marked1"><a name="line197" />197 					Thread.pass
</span><span class="inferred0"><a name="line198" />198 				end
</span><span class="uncovered1"><a name="line199" />199 			end; end
</span><span class="uncovered0"><a name="line200" />200 		rescue Exception =&gt; e
</span><span class="uncovered1"><a name="line201" />201 			err format_error(e)
</span><span class="uncovered0"><a name="line202" />202 		end
</span><span class="marked1"><a name="line203" />203 		done!
</span><span class="marked0"><a name="line204" />204 		nil
</span><span class="inferred1"><a name="line205" />205 	end
</span><span class="inferred0"><a name="line206" />206 
</span><span class="inferred1"><a name="line207" />207 	# require that an operation be in global scope
</span><span class="marked0"><a name="line208" />208 	def global_required
</span><span class="marked1"><a name="line209" />209 		return if current_state == :global
</span><span class="uncovered0"><a name="line210" />210 		raise &quot;operation not allowed dynamically&quot;
</span><span class="uncovered1"><a name="line211" />211 	end
</span><span class="inferred0"><a name="line212" />212 
</span><span class="inferred1"><a name="line213" />213 	# require that an operation NOT be in global scope
</span><span class="marked0"><a name="line214" />214 	def global_forbidden
</span><span class="uncovered1"><a name="line215" />215 		return if current_state != :global
</span><span class="uncovered0"><a name="line216" />216 		raise &quot;operation not allowed globally&quot;
</span><span class="uncovered1"><a name="line217" />217 	end
</span><span class="inferred0"><a name="line218" />218 
</span><span class="inferred1"><a name="line219" />219 	# join the environment's main thread. calls to join may block
</span><span class="inferred0"><a name="line220" />220 	# and may throw exceptions from scripts.
</span><span class="marked1"><a name="line221" />221 	def join(timeout=nil)
</span><span class="marked0"><a name="line222" />222 		@main_thread.join(@timeout||timeout) if @main_thread
</span><span class="marked1"><a name="line223" />223 		@pipe_thread.join(@timeout||timeout) if @pipe_thread
</span><span class="marked0"><a name="line224" />224 		@io_thread.join(@timeout||timeout) if @io_thread
</span><span class="inferred1"><a name="line225" />225 		# fail(@error[0]) if @error and @error[0]
</span><span class="marked0"><a name="line226" />226 		exit unless @in_memory
</span><span class="marked1"><a name="line227" />227 		nil
</span><span class="inferred0"><a name="line228" />228 	end
</span><span class="inferred1"><a name="line229" />229 
</span><span class="inferred0"><a name="line230" />230 	# signal main thread completion
</span><span class="marked1"><a name="line231" />231 	def done!
</span><span class="marked0"><a name="line232" />232 		@done = true
</span><span class="marked1"><a name="line233" />233 		@main_thread = nil
</span><span class="inferred0"><a name="line234" />234 	end
</span><span class="inferred1"><a name="line235" />235 
</span><span class="inferred0"><a name="line236" />236 	# first, tell the script to exit, then tell IO to stop
</span><span class="inferred1"><a name="line237" />237 	# (which it won't until the script does)
</span><span class="marked0"><a name="line238" />238 	def shutdown!(message_id=nil)
</span><span class="marked1"><a name="line239" />239 		return if @shutdown
</span><span class="marked0"><a name="line240" />240 		@pipe.write Message.system(:quit, :message_id =&gt; message_id)
</span><span class="marked1"><a name="line241" />241 		@quit_sent = true
</span><span class="marked0"><a name="line242" />242 		@sandbox[:exit] = true
</span><span class="marked1"><a name="line243" />243 		@shutdown = true
</span><span class="inferred0"><a name="line244" />244 	end
</span><span class="inferred1"><a name="line245" />245 
</span><span class="inferred0"><a name="line246" />246 	# threads exit when shutdown signalled and scripts exit
</span><span class="marked1"><a name="line247" />247 	def shutdown?
</span><span class="marked0"><a name="line248" />248 		@shutdown &amp;&amp; @done
</span><span class="marked1"><a name="line249" />249 	end
</span><span class="inferred0"><a name="line250" />250 
</span><span class="inferred1"><a name="line251" />251 	# pipe reader
</span><span class="marked0"><a name="line252" />252 	def pipe_main
</span><span class="marked1"><a name="line253" />253 		until shutdown?
</span><span class="marked0"><a name="line254" />254 			Thread.pass until @pipe
</span><span class="marked1"><a name="line255" />255 			message = @pipe.read
</span><span class="marked0"><a name="line256" />256 			if message
</span><span class="marked1"><a name="line257" />257 				sync :inbox do
</span><span class="marked0"><a name="line258" />258 					@inbox &lt;&lt; message
</span><span class="inferred1"><a name="line259" />259 				end
</span><span class="marked0"><a name="line260" />260 				break if message.command == :quit
</span><span class="inferred1"><a name="line261" />261 			end
</span><span class="marked0"><a name="line262" />262 			Thread.pass
</span><span class="inferred1"><a name="line263" />263 		end
</span><span class="marked0"><a name="line264" />264 		@pipe_closed = true
</span><span class="inferred1"><a name="line265" />265 	end
</span><span class="inferred0"><a name="line266" />266 
</span><span class="inferred1"><a name="line267" />267 	# io processing loop
</span><span class="marked0"><a name="line268" />268 	def io_main
</span><span class="marked1"><a name="line269" />269 		until shutdown? &amp;&amp; @pipe_closed &amp;&amp; @quit_sent
</span><span class="marked0"><a name="line270" />270 			handle_messages
</span><span class="marked1"><a name="line271" />271 			send_messages
</span><span class="marked0"><a name="line272" />272 			Thread.pass
</span><span class="inferred1"><a name="line273" />273 		end
</span><span class="marked0"><a name="line274" />274 		@pipe.close
</span><span class="marked1"><a name="line275" />275 		@io_done = true
</span><span class="inferred0"><a name="line276" />276 	end
</span><span class="inferred1"><a name="line277" />277 
</span><span class="inferred0"><a name="line278" />278 	# handle messages in inbox
</span><span class="marked1"><a name="line279" />279 	def handle_messages
</span><span class="marked0"><a name="line280" />280 		until @inbox.empty?
</span><span class="marked1"><a name="line281" />281 			message = sync :inbox do
</span><span class="marked0"><a name="line282" />282 				@inbox.shift
</span><span class="inferred1"><a name="line283" />283 			end
</span><span class="marked0"><a name="line284" />284 			next unless message
</span><span class="marked1"><a name="line285" />285 			handle message
</span><span class="inferred0"><a name="line286" />286 		end
</span><span class="marked1"><a name="line287" />287 	end
</span><span class="inferred0"><a name="line288" />288 
</span><span class="inferred1"><a name="line289" />289 	# send messages from outbox
</span><span class="marked0"><a name="line290" />290 	def send_messages
</span><span class="marked1"><a name="line291" />291 		until @outbox.empty?
</span><span class="marked0"><a name="line292" />292 			message = sync :outbox do
</span><span class="marked1"><a name="line293" />293 				@outbox.shift
</span><span class="inferred0"><a name="line294" />294 			end
</span><span class="marked1"><a name="line295" />295 			send_message message
</span><span class="inferred0"><a name="line296" />296 		end
</span><span class="marked1"><a name="line297" />297 	end
</span><span class="inferred0"><a name="line298" />298 
</span><span class="inferred1"><a name="line299" />299 	# handle a message
</span><span class="marked0"><a name="line300" />300 	def handle(message)
</span><span class="marked1"><a name="line301" />301 		begin
</span><span class="marked0"><a name="line302" />302 			case message.command
</span><span class="marked1"><a name="line303" />303 			when :start then run!
</span><span class="marked0"><a name="line304" />304 			when :quit
</span><span class="marked1"><a name="line305" />305 				shutdown!(message[:message_id])
</span><span class="marked0"><a name="line306" />306 				@timeout = message[:timeout] # FIXME: ???
</span><span class="marked1"><a name="line307" />307 			when :load then
</span><span class="marked0"><a name="line308" />308 				add_script message[:file]
</span><span class="marked1"><a name="line309" />309 				@outbox &lt;&lt; [:loaded, nil, nil, message.params]
</span><span class="marked0"><a name="line310" />310 			when :mapped then nil
</span><span class="marked1"><a name="line311" />311 			when :reply then handle_reply message
</span><span class="inferred0"><a name="line312" />312 			# TODO: get source host in action message
</span><span class="marked1"><a name="line313" />313 			when :action
</span><span class="inferred0"><a name="line314" />314 				# FIXME: we need to decide when path is a string vs. URI
</span><span class="marked1"><a name="line315" />315 				dbg &quot;received action request: #{message.url}&quot;
</span><span class="marked0"><a name="line316" />316 				path = message.url
</span><span class="marked1"><a name="line317" />317 				path = path.path if path.kind_of? URI
</span><span class="marked0"><a name="line318" />318 				action path, message.params
</span><span class="uncovered1"><a name="line319" />319 			else
</span><span class="uncovered0"><a name="line320" />320 				params = message.params.merge({:command =&gt; message.command})
</span><span class="uncovered1"><a name="line321" />321 				@outbox &lt;&lt; [:no_command, nil, nil, params]
</span><span class="uncovered0"><a name="line322" />322 			end
</span><span class="uncovered1"><a name="line323" />323 		rescue Exception =&gt; e
</span><span class="uncovered0"><a name="line324" />324 			err format_error(e), message[:message_id]
</span><span class="uncovered1"><a name="line325" />325 		end
</span><span class="marked0"><a name="line326" />326 	end
</span><span class="inferred1"><a name="line327" />327 
</span><span class="inferred0"><a name="line328" />328 	# handle a GET or POST message reply
</span><span class="marked1"><a name="line329" />329 	def handle_reply(message)
</span><span class="uncovered0"><a name="line330" />330 		sync :replies do
</span><span class="uncovered1"><a name="line331" />331 			@replies &lt;&lt; message
</span><span class="uncovered0"><a name="line332" />332 		end
</span><span class="uncovered1"><a name="line333" />333 	end
</span><span class="inferred0"><a name="line334" />334 
</span><span class="inferred1"><a name="line335" />335 	# delete a reply from the incoming array
</span><span class="marked0"><a name="line336" />336 	def delete_reply(message)
</span><span class="uncovered1"><a name="line337" />337 		@replies.delete message
</span><span class="uncovered0"><a name="line338" />338 	end
</span><span class="inferred1"><a name="line339" />339 
</span><span class="inferred0"><a name="line340" />340 	# call an action on the environment
</span><span class="marked1"><a name="line341" />341 	def action(path, params)
</span><span class="marked0"><a name="line342" />342 		Thread.new(self, path, params) do |env,path,params|
</span><span class="marked1"><a name="line343" />343 			$_params = params
</span><span class="marked0"><a name="line344" />344 			$path = path
</span><span class="marked1"><a name="line345" />345 			begin
</span><span class="inferred0"><a name="line346" />346 				# first look for a handler
</span><span class="marked1"><a name="line347" />347 				block, obj = resolve_handler path
</span><span class="marked0"><a name="line348" />348 				dbg &quot;resolved (listen) handler for #{path}&quot; if block
</span><span class="inferred1"><a name="line349" />349 				# otherwise look for an action
</span><span class="marked0"><a name="line350" />350 				unless block
</span><span class="marked1"><a name="line351" />351 					map_id, action = env.resolve_path path, params
</span><span class="marked0"><a name="line352" />352 					block = env.resolve_action map_id, action, params
</span><span class="marked1"><a name="line353" />353 					dbg &quot;resolved (function) handler for #{path}&quot;
</span><span class="marked0"><a name="line354" />354 					obj = @sandbox
</span><span class="inferred1"><a name="line355" />355 				end
</span><span class="uncovered0"><a name="line356" />356 			rescue Exception =&gt; e
</span><span class="uncovered1"><a name="line357" />357 				reply :error =&gt; format_error(e)
</span><span class="uncovered0"><a name="line358" />358 			end
</span><span class="marked1"><a name="line359" />359 			if block
</span><span class="marked0"><a name="line360" />360 				dbg &quot;calling handler&quot;
</span><span class="inferred1"><a name="line361" />361 				# TODO: set source host
</span><span class="marked0"><a name="line362" />362 				begin
</span><span class="marked1"><a name="line363" />363 					$env = env.instance_variable_get :@sandbox
</span><span class="marked0"><a name="line364" />364 					env.sandbox(:obj =&gt; obj) do
</span><span class="marked1"><a name="line365" />365 						@obj.instance_exec &amp;block
</span><span class="inferred0"><a name="line366" />366 					end
</span><span class="uncovered1"><a name="line367" />367 				rescue Exception =&gt; e
</span><span class="uncovered0"><a name="line368" />368 					reply :error =&gt; format_error(e)
</span><span class="uncovered1"><a name="line369" />369 				end
</span><span class="marked0"><a name="line370" />370 				reply unless $_params[:replied]
</span><span class="uncovered1"><a name="line371" />371 			else
</span><span class="uncovered0"><a name="line372" />372 				@outbox &lt;&lt; [:not_found, nil, nil, params.merge({:path =&gt; path})]
</span><span class="uncovered1"><a name="line373" />373 			end
</span><span class="uncovered0"><a name="line374" />374 		end
</span><span class="marked1"><a name="line375" />375 	end
</span><span class="inferred0"><a name="line376" />376 
</span><span class="inferred1"><a name="line377" />377 	# look up a handler for this path
</span><span class="marked0"><a name="line378" />378 	def resolve_handler(path)
</span><span class="marked1"><a name="line379" />379 		parts = path.split('/').reject {|s| s.empty?}
</span><span class="marked0"><a name="line380" />380 		@handlers.each do |regex,block|
</span><span class="uncovered1"><a name="line381" />381 			return block if regex =~ parts[0]
</span><span class="uncovered0"><a name="line382" />382 		end
</span><span class="marked1"><a name="line383" />383 		nil
</span><span class="inferred0"><a name="line384" />384 	end
</span><span class="inferred1"><a name="line385" />385 
</span><span class="inferred0"><a name="line386" />386 	# resolve path into map context and action name
</span><span class="marked1"><a name="line387" />387 	def resolve_path(path, params)
</span><span class="marked0"><a name="line388" />388 		parts = path.split('/').reject {|s| s.empty?}
</span><span class="marked1"><a name="line389" />389 		map_id = parts.shift
</span><span class="marked0"><a name="line390" />390 		while parts.size &gt; 1
</span><span class="uncovered1"><a name="line391" />391 			map_id = resolve_part map_id, parts.shift, path, params
</span><span class="uncovered0"><a name="line392" />392 			return nil, nil unless map_id
</span><span class="uncovered1"><a name="line393" />393 		end
</span><span class="marked0"><a name="line394" />394 		part = parts.shift || ''
</span><span class="marked1"><a name="line395" />395 		return map_id, part
</span><span class="inferred0"><a name="line396" />396 	end
</span><span class="inferred1"><a name="line397" />397 
</span><span class="inferred0"><a name="line398" />398 	# resolve part of a path
</span><span class="marked1"><a name="line399" />399 	def resolve_part(map_id, part, path, params)
</span><span class="uncovered0"><a name="line400" />400 		if @url_patterns[map_id].nil?
</span><span class="uncovered1"><a name="line401" />401 			return(host_error(:no_path, path, params))
</span><span class="uncovered0"><a name="line402" />402 		end
</span><span class="uncovered1"><a name="line403" />403 		ids = @url_patterns[map_id].keys.select do |pattern|
</span><span class="uncovered0"><a name="line404" />404 			pattern =~ part
</span><span class="uncovered1"><a name="line405" />405 		end
</span><span class="uncovered0"><a name="line406" />406 		if ids.empty?
</span><span class="uncovered1"><a name="line407" />407 			return(host_error :no_path, path, params)
</span><span class="uncovered0"><a name="line408" />408 		elsif ids.size &gt; 1
</span><span class="uncovered1"><a name="line409" />409 			return(host_error :ambiguous_path, path, params)
</span><span class="uncovered0"><a name="line410" />410 		else
</span><span class="uncovered1"><a name="line411" />411 			return(@url_patterns[map_id][ids[0]])
</span><span class="uncovered0"><a name="line412" />412 		end
</span><span class="uncovered1"><a name="line413" />413 	end
</span><span class="inferred0"><a name="line414" />414 
</span><span class="inferred1"><a name="line415" />415 	# resolve action name in map context into block
</span><span class="marked0"><a name="line416" />416 	def resolve_action(map_id, action, params)
</span><span class="marked1"><a name="line417" />417 		return nil unless map_id &amp;&amp; action
</span><span class="marked0"><a name="line418" />418 		action = action.to_sym unless action == &quot;&quot;
</span><span class="marked1"><a name="line419" />419 		block, visibility = @listeners[map_id][action]
</span><span class="inferred0"><a name="line420" />420 		# TODO: check visibility
</span><span class="marked1"><a name="line421" />421 		return block
</span><span class="inferred0"><a name="line422" />422 	end
</span><span class="inferred1"><a name="line423" />423 
</span><span class="inferred0"><a name="line424" />424 	# send error message to host controller
</span><span class="marked1"><a name="line425" />425 	def host_error(error, path, params)
</span><span class="uncovered0"><a name="line426" />426 		@outbox &lt;&lt; [error, nil, nil, params.merge({:path =&gt; path})]
</span><span class="uncovered1"><a name="line427" />427 		nil
</span><span class="uncovered0"><a name="line428" />428 	end
</span><span class="inferred1"><a name="line429" />429 
</span><span class="inferred0"><a name="line430" />430 	# format an action error into something to send as a reply
</span><span class="marked1"><a name="line431" />431 	def format_error(error)
</span><span class="uncovered0"><a name="line432" />432 		&quot;#{error}\n&quot; + (error.backtrace.map{|l| &quot;\t#{l}&quot;}).join(&quot;\n&quot;)
</span><span class="uncovered1"><a name="line433" />433 	end
</span><span class="inferred0"><a name="line434" />434 
</span><span class="inferred1"><a name="line435" />435 	# send outgoing message to host
</span><span class="marked0"><a name="line436" />436 	def send_message(message)
</span><span class="marked1"><a name="line437" />437 		command, host, url, params, result, done = message
</span><span class="inferred0"><a name="line438" />438 
</span><span class="marked1"><a name="line439" />439 		msg = if not (host or url)
</span><span class="marked0"><a name="line440" />440 			Message.system(command, params)
</span><span class="inferred1"><a name="line441" />441 		else
</span><span class="marked0"><a name="line442" />442 			Message.new(command, host, url, params)
</span><span class="inferred1"><a name="line443" />443 		end
</span><span class="inferred0"><a name="line444" />444 
</span><span class="marked1"><a name="line445" />445 		@pipe.write msg
</span><span class="inferred0"><a name="line446" />446 
</span><span class="marked1"><a name="line447" />447 		begin
</span><span class="inferred0"><a name="line448" />448 			# FIXME: sync/async should be an arg of the message maybe?
</span><span class="marked1"><a name="line449" />449 			if [:get, :post, :put, :delete].include? command
</span><span class="marked0"><a name="line450" />450 				wait_for_reply_to msg, result, done
</span><span class="inferred1"><a name="line451" />451 			end
</span><span class="uncovered0"><a name="line452" />452 		rescue Exception =&gt; e
</span><span class="uncovered1"><a name="line453" />453 			err format_error(e)
</span><span class="uncovered0"><a name="line454" />454 		end
</span><span class="inferred1"><a name="line455" />455 
</span><span class="marked0"><a name="line456" />456 		nil
</span><span class="inferred1"><a name="line457" />457 	end
</span><span class="inferred0"><a name="line458" />458 
</span><span class="inferred1"><a name="line459" />459 	# wait for a reply in a new thread
</span><span class="marked0"><a name="line460" />460 	def wait_for_reply_to(message, result, status)
</span><span class="marked1"><a name="line461" />461 		Thread.new(self) do |env|
</span><span class="marked0"><a name="line462" />462 			begin
</span><span class="marked1"><a name="line463" />463 				found = false
</span><span class="marked0"><a name="line464" />464 				while !found
</span><span class="marked1"><a name="line465" />465 					sync :replies do
</span><span class="marked0"><a name="line466" />466 						@replies.each do |reply|
</span><span class="uncovered1"><a name="line467" />467 							next unless reply.replies_to? message
</span><span class="uncovered0"><a name="line468" />468 							env.delete_reply reply
</span><span class="uncovered1"><a name="line469" />469 							result &lt;&lt; reply
</span><span class="uncovered0"><a name="line470" />470 							status &lt;&lt; reply[:error] || :ok
</span><span class="uncovered1"><a name="line471" />471 							found = true
</span><span class="uncovered0"><a name="line472" />472 							break
</span><span class="uncovered1"><a name="line473" />473 						end
</span><span class="uncovered0"><a name="line474" />474 					end
</span><span class="marked1"><a name="line475" />475 					Thread.pass
</span><span class="inferred0"><a name="line476" />476 				end
</span><span class="uncovered1"><a name="line477" />477 			rescue Exception =&gt; e
</span><span class="uncovered0"><a name="line478" />478 				err format_error(e)
</span><span class="uncovered1"><a name="line479" />479 			end
</span><span class="uncovered0"><a name="line480" />480 		end
</span><span class="marked1"><a name="line481" />481 	end
</span><span class="inferred0"><a name="line482" />482 
</span><span class="inferred1"><a name="line483" />483 	# map a sub-url pattern
</span><span class="marked0"><a name="line484" />484 	def map_pattern(pattern, &amp;block)
</span><span class="uncovered1"><a name="line485" />485 		protect :map_id do |old_map_id|
</span><span class="uncovered0"><a name="line486" />486 			@map_id += &quot;\\/&quot; + pattern.source
</span><span class="uncovered1"><a name="line487" />487 			@url_patterns[old_map_id] ||= {}.taint
</span><span class="uncovered0"><a name="line488" />488 			@url_patterns[old_map_id][pattern] = @map_id
</span><span class="uncovered1"><a name="line489" />489 			sandbox &amp;block
</span><span class="uncovered0"><a name="line490" />490 		end
</span><span class="uncovered1"><a name="line491" />491 	end
</span><span class="inferred0"><a name="line492" />492 
</span><span class="inferred1"><a name="line493" />493 	# map a root url
</span><span class="marked0"><a name="line494" />494 	def map_root(prefix, &amp;block)
</span><span class="marked1"><a name="line495" />495 		global_required
</span><span class="marked0"><a name="line496" />496 		protect :map_id, :protection_level do
</span><span class="marked1"><a name="line497" />497 			@map_id = prefix.to_s
</span><span class="marked0"><a name="line498" />498 			@protection_level = :public
</span><span class="marked1"><a name="line499" />499 			@outbox &lt;&lt; [:map, nil, nil, {:regex =&gt; /#{prefix}/}]
</span><span class="marked0"><a name="line500" />500 			sandbox &amp;block
</span><span class="inferred1"><a name="line501" />501 		end
</span><span class="inferred0"><a name="line502" />502 	end
</span><span class="inferred1"><a name="line503" />503 
</span><span class="inferred0"><a name="line504" />504 	######################
</span><span class="inferred1"><a name="line505" />505 	## SCRIPT FUNCTIONS ##
</span><span class="inferred0"><a name="line506" />506 	######################
</span><span class="inferred1"><a name="line507" />507 
</span><span class="inferred0"><a name="line508" />508 	# the current state
</span><span class="marked1"><a name="line509" />509 	def current_state
</span><span class="marked0"><a name="line510" />510 		@state[0]
</span><span class="marked1"><a name="line511" />511 	end
</span><span class="inferred0"><a name="line512" />512 
</span><span class="inferred1"><a name="line513" />513 	# require another file (depth-first order)
</span><span class="marked0"><a name="line514" />514 	def req(script)
</span><span class="marked1"><a name="line515" />515 		unless @included.include? script
</span><span class="marked0"><a name="line516" />516 			@required &lt;&lt; script
</span><span class="marked1"><a name="line517" />517 			raise &quot;require&quot;
</span><span class="inferred0"><a name="line518" />518 		end
</span><span class="marked1"><a name="line519" />519 	end
</span><span class="inferred0"><a name="line520" />520 
</span><span class="inferred1"><a name="line521" />521 	# map a host url pattern
</span><span class="marked0"><a name="line522" />522 	def map(arg, &amp;block)
</span><span class="marked1"><a name="line523" />523 		@map_id ? map_pattern(arg, &amp;block) : map_root(arg, &amp;block)
</span><span class="inferred0"><a name="line524" />524 	end
</span><span class="inferred1"><a name="line525" />525 
</span><span class="inferred0"><a name="line526" />526 	# look up a class
</span><span class="marked1"><a name="line527" />527 	def k(name)
</span><span class="uncovered0"><a name="line528" />528 		@classes[current_state][name] || @classes[:global][name]
</span><span class="uncovered1"><a name="line529" />529 	end
</span><span class="inferred0"><a name="line530" />530 
</span><span class="inferred1"><a name="line531" />531 	# jump to another state
</span><span class="marked0"><a name="line532" />532 	def goto(state)
</span><span class="marked1"><a name="line533" />533 		raise &quot;invalid state&quot; unless @states.include? state
</span><span class="marked0"><a name="line534" />534 		@state[0] = state
</span><span class="inferred1"><a name="line535" />535 	end
</span><span class="inferred0"><a name="line536" />536 
</span><span class="inferred1"><a name="line537" />537 	# exit the state machine
</span><span class="marked0"><a name="line538" />538 	def quit
</span><span class="marked1"><a name="line539" />539 		@exit = true
</span><span class="marked0"><a name="line540" />540 	end
</span><span class="inferred1"><a name="line541" />541 
</span><span class="inferred0"><a name="line542" />542 	# declare a function in this state
</span><span class="inferred1"><a name="line543" />543 	# if it's inside a map block, it will be used
</span><span class="inferred0"><a name="line544" />544 	# as a message handler
</span><span class="marked1"><a name="line545" />545 	def function(name, &amp;block)
</span><span class="marked0"><a name="line546" />546 		if @map_id
</span><span class="marked1"><a name="line547" />547 			log &quot;mapping listener #{@map_id}/#{name}&quot;
</span><span class="marked0"><a name="line548" />548 			@listeners[@map_id] ||= {}.taint
</span><span class="marked1"><a name="line549" />549 			@listeners[@map_id][name] = [block, @protection_level]
</span><span class="inferred0"><a name="line550" />550 		else
</span><span class="marked1"><a name="line551" />551 			@functions[current_state][name.to_sym] = block
</span><span class="marked0"><a name="line552" />552 			@sandbox.delegate name, self
</span><span class="inferred1"><a name="line553" />553 		end
</span><span class="inferred0"><a name="line554" />554 	end
</span><span class="marked1"><a name="line555" />555 	alias :fun :function
</span><span class="inferred0"><a name="line556" />556 
</span><span class="inferred1"><a name="line557" />557 	# declare a url map that is also a function,
</span><span class="inferred0"><a name="line558" />558 	# which is the same as a map block containing
</span><span class="inferred1"><a name="line559" />559 	# a function which handles all requests
</span><span class="marked0"><a name="line560" />560 	def listen(regex, object=@sandbox, &amp;block)
</span><span class="marked1"><a name="line561" />561 		raise &quot;you are missing the point&quot; if @map_id
</span><span class="marked0"><a name="line562" />562 		@handlers[regex] = [block, object]
</span><span class="inferred1"><a name="line563" />563 		# FIXME: we shouldn't need regex as the path, right?
</span><span class="marked0"><a name="line564" />564 		@outbox &lt;&lt; [:map, nil, regex, {:regex =&gt; regex}]
</span><span class="inferred1"><a name="line565" />565 	end
</span><span class="inferred0"><a name="line566" />566 
</span><span class="inferred1"><a name="line567" />567 	# XXX delegates to REST XXX including the module is enough.
</span><span class="inferred0"><a name="line568" />568 	#                           (altho it might be a security hole).
</span><span class="inferred1"><a name="line569" />569 	# delegate &quot;REST::&quot;, :entity, :behavior, :store, :map_rest
</span><span class="inferred0"><a name="line570" />570 
</span><span class="inferred1"><a name="line571" />571 	# declare a new class in this state
</span><span class="marked0"><a name="line572" />572 	def klass(name, parent=nil, &amp;block)
</span><span class="uncovered1"><a name="line573" />573 		parent = k(parent) if parent
</span><span class="uncovered0"><a name="line574" />574 		@classes[current_state][name] = Class.new parent, &amp;block
</span><span class="uncovered1"><a name="line575" />575 	end
</span><span class="inferred0"><a name="line576" />576 
</span><span class="inferred1"><a name="line577" />577 	# declare a new state (nested states not allowed)
</span><span class="marked0"><a name="line578" />578 	def state(name, &amp;block)
</span><span class="marked1"><a name="line579" />579 		global_required
</span><span class="marked0"><a name="line580" />580 		@states &lt;&lt; name unless @states.include? name
</span><span class="marked1"><a name="line581" />581 		@functions[name] ||= {}.taint
</span><span class="marked0"><a name="line582" />582 		@classes[name] ||= {}.taint
</span><span class="marked1"><a name="line583" />583 		goto name
</span><span class="marked0"><a name="line584" />584 		sandbox &amp;block
</span><span class="marked1"><a name="line585" />585 		goto :global
</span><span class="inferred0"><a name="line586" />586 	end
</span><span class="inferred1"><a name="line587" />587 
</span><span class="inferred0"><a name="line588" />588 	# protection level for message handlers;
</span><span class="inferred1"><a name="line589" />589 	# private handlers can only be accessed from
</span><span class="inferred0"><a name="line590" />590 	# hosts in an ACL, by default just the handling
</span><span class="inferred1"><a name="line591" />591 	# host
</span><span class="marked0"><a name="line592" />592 	def private
</span><span class="uncovered1"><a name="line593" />593 		@protection_level = :private
</span><span class="uncovered0"><a name="line594" />594 	end
</span><span class="inferred1"><a name="line595" />595 
</span><span class="marked0"><a name="line596" />596 	def public
</span><span class="uncovered1"><a name="line597" />597 		@protection_level = :public
</span><span class="uncovered0"><a name="line598" />598 	end
</span><span class="inferred1"><a name="line599" />599 
</span><span class="inferred0"><a name="line600" />600 	# get action parameters
</span><span class="marked1"><a name="line601" />601 	def params
</span><span class="uncovered0"><a name="line602" />602 		$_params
</span><span class="uncovered1"><a name="line603" />603 	end
</span><span class="inferred0"><a name="line604" />604 
</span><span class="inferred1"><a name="line605" />605 	# add something safely to outbox array
</span><span class="marked0"><a name="line606" />606 	def &lt;&lt;(message)
</span><span class="marked1"><a name="line607" />607 		sync :outbox do
</span><span class="marked0"><a name="line608" />608 			@outbox &lt;&lt; message
</span><span class="inferred1"><a name="line609" />609 		end
</span><span class="marked0"><a name="line610" />610 	end
</span><span class="inferred1"><a name="line611" />611 
</span><span class="inferred0"><a name="line612" />612 	# thread pass
</span><span class="marked1"><a name="line613" />613 	def pass
</span><span class="uncovered0"><a name="line614" />614 		Thread.pass
</span><span class="uncovered1"><a name="line615" />615 	end
</span><span class="inferred0"><a name="line616" />616   
</span><span class="inferred1"><a name="line617" />617   # command request helpers
</span><span class="marked0"><a name="line618" />618   def get(url, body, params)
</span><span class="uncovered1"><a name="line619" />619     handle_request :get, url, body, params
</span><span class="uncovered0"><a name="line620" />620   end
</span><span class="inferred1"><a name="line621" />621   
</span><span class="marked0"><a name="line622" />622   def put(url, body, params)
</span><span class="uncovered1"><a name="line623" />623     handle_request :put, url, body, params
</span><span class="uncovered0"><a name="line624" />624   end
</span><span class="inferred1"><a name="line625" />625   
</span><span class="marked0"><a name="line626" />626   def post(url, body, params)
</span><span class="uncovered1"><a name="line627" />627     handle_request :post, url, body, params
</span><span class="uncovered0"><a name="line628" />628   end
</span><span class="inferred1"><a name="line629" />629   
</span><span class="marked0"><a name="line630" />630   def delete(url, body, params)
</span><span class="uncovered1"><a name="line631" />631     handle_request :delete, url, body, params
</span><span class="uncovered0"><a name="line632" />632   end
</span><span class="inferred1"><a name="line633" />633     
</span><span class="marked0"><a name="line634" />634   def handle_request (verb, url, body, params)
</span><span class="uncovered1"><a name="line635" />635     uri = URI.parse url
</span><span class="uncovered0"><a name="line636" />636     host = &quot;#{uri.host}:#{uri.port}&quot;.to_host
</span><span class="uncovered1"><a name="line637" />637     result, status = [], []
</span><span class="uncovered0"><a name="line638" />638     @outbox &lt;&lt; [verb, host, uri.path, params.merge({:body =&gt; body}), result, status]
</span><span class="uncovered1"><a name="line639" />639     Thread.pass while result.empty?
</span><span class="uncovered0"><a name="line640" />640     reply = result[0]
</span><span class="uncovered1"><a name="line641" />641     [reply[:code], reply[:body]]
</span><span class="uncovered0"><a name="line642" />642   end
</span><span class="inferred1"><a name="line643" />643 
</span><span class="inferred0"><a name="line644" />644 	# reply to a GET or POST
</span><span class="marked1"><a name="line645" />645 	def reply(params = {})
</span><span class="marked0"><a name="line646" />646 		if $_params[:replied]
</span><span class="uncovered1"><a name="line647" />647 			puts &quot;----------&quot;
</span><span class="uncovered0"><a name="line648" />648 			puts caller[0,10]
</span><span class="uncovered1"><a name="line649" />649 			puts &quot;----------&quot;
</span><span class="uncovered0"><a name="line650" />650 			puts $_params[:replied][0,10]
</span><span class="uncovered1"><a name="line651" />651 		end
</span><span class="marked0"><a name="line652" />652 		raise &quot;already replied!&quot; if $_params[:replied]
</span><span class="marked1"><a name="line653" />653 		$_params[:replied] = caller
</span><span class="marked0"><a name="line654" />654 		params[:code] ||= 200 unless params[:error]
</span><span class="marked1"><a name="line655" />655 		params[:message_id] = $_params[:message_id]
</span><span class="marked0"><a name="line656" />656 		dbg &quot;replying: #{params.inspect}&quot;
</span><span class="marked1"><a name="line657" />657 		@outbox &lt;&lt; [:reply, nil, nil, params]
</span><span class="inferred0"><a name="line658" />658 	end
</span><span class="inferred1"><a name="line659" />659 
</span><span class="inferred0"><a name="line660" />660 	# send a debug message
</span><span class="marked1"><a name="line661" />661 	def dbg(msg)
</span><span class="marked0"><a name="line662" />662 		log msg, :level =&gt; :debug
</span><span class="marked1"><a name="line663" />663 	end
</span><span class="inferred0"><a name="line664" />664 
</span><span class="inferred1"><a name="line665" />665 	# send a log message
</span><span class="marked0"><a name="line666" />666 	def log(msg, options={})
</span><span class="marked1"><a name="line667" />667 		@outbox &lt;&lt; [:log, nil, nil, options.merge({:message =&gt; msg})]
</span><span class="marked0"><a name="line668" />668 	end
</span><span class="inferred1"><a name="line669" />669 
</span><span class="inferred0"><a name="line670" />670 	# send an error message
</span><span class="marked1"><a name="line671" />671 	def err(msg, message_id=nil)
</span><span class="uncovered0"><a name="line672" />672 		@outbox &lt;&lt; [:error, nil, nil, {:message =&gt; msg, :message_id =&gt; message_id}]
</span><span class="uncovered1"><a name="line673" />673 	end
</span><span class="inferred0"><a name="line674" />674 
</span><span class="inferred1"><a name="line675" />675 	# try to call a script-defined function
</span><span class="marked0"><a name="line676" />676 	def method_missing(id, *args, &amp;block)
</span><span class="marked1"><a name="line677" />677 		untraced(5) do
</span><span class="marked0"><a name="line678" />678 			name = id.id2name.to_sym
</span><span class="marked1"><a name="line679" />679 			[current_state, :global].each do |state|
</span><span class="marked0"><a name="line680" />680 				next unless @functions[state].include? name
</span><span class="marked1"><a name="line681" />681 				return sandbox do
</span><span class="marked0"><a name="line682" />682 					begin
</span><span class="marked1"><a name="line683" />683 						@functions[state][name].call *args, &amp;block
</span><span class="inferred0"><a name="line684" />684 					rescue Exception =&gt; e
</span><span class="marked1"><a name="line685" />685 						self.rename_backtrace e, name
</span><span class="marked0"><a name="line686" />686 						fail e
</span><span class="inferred1"><a name="line687" />687 					end
</span><span class="marked0"><a name="line688" />688 				end
</span><span class="inferred1"><a name="line689" />689 			end
</span><span class="inferred0"><a name="line690" />690 		end
</span><span class="uncovered1"><a name="line691" />691 		super id, *args
</span><span class="uncovered0"><a name="line692" />692 	end
</span><span class="uncovered1"><a name="line693" />693 
</span><span class="uncovered0"><a name="line694" />694 end
</span></pre><hr />    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a> version 0.8.0.</p><p>
          <a href='http://validator.w3.org/check/referer'>
            <img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88' />
          </a>
          <a href='http://jigsaw.w3.org/css-validator/check/referer'>
            <img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px' />
          </a>
        </p>
      </body>
    </html>
